// Copyright (c) 2024-present The QSBitcoin developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <bitcoin-build-config.h> // IWYU pragma: keep

#include <core_io.h>
#include <key_io.h>
#include <rpc/util.h>
#include <script/script.h>
#include <script/solver.h>
#include <script/descriptor.h>
#include <script/quantum_witness.h>
#include <util/bip32.h>
#include <util/translation.h>
#include <wallet/receive.h>
#include <wallet/rpc/util.h>
#include <wallet/wallet.h>
#include <wallet/walletdb.h>
#include <wallet/scriptpubkeyman.h>
#include <wallet/quantum_wallet_setup.h>
#include <crypto/quantum_key.h>
#include <quantum_address.h>
#include <script/quantum_signature.h>
#include <common/signmessage.h>
#include <util/strencodings.h>
#include <hash.h>
#include <crypto/sha256.h>

#include <univalue.h>

namespace wallet {

using quantum::CQuantumKey;
using quantum::CQuantumPubKey;

// getnewquantumaddress has been removed - use getnewaddress with algorithm parameter instead

RPCHelpMan validatequantumaddress()
{
    return RPCHelpMan{
        "validatequantumaddress",
        "DEPRECATED: Quantum addresses now use standard bech32 P2WSH format.\n"
        "Use validateaddress instead. This RPC is kept for backward compatibility.\n",
        {
            {"address", RPCArg::Type::STR, RPCArg::Optional::NO, "The bitcoin address to validate"},
        },
        RPCResult{
            RPCResult::Type::OBJ, "", "",
            {
                {RPCResult::Type::BOOL, "isvalid", "If the address is valid or not"},
                {RPCResult::Type::STR, "address", /*optional=*/true, "The quantum bitcoin address validated"},
                {RPCResult::Type::STR, "algorithm", /*optional=*/true, "The quantum signature algorithm used (ml-dsa or slh-dsa)"},
                {RPCResult::Type::STR, "type", /*optional=*/true, "The type of address (P2QPKH_ML_DSA, P2QPKH_SLH_DSA, or P2QSH)"},
                {RPCResult::Type::STR_HEX, "scriptPubKey", /*optional=*/true, "The hex-encoded output script generated by the address"},
                {RPCResult::Type::BOOL, "isscript", /*optional=*/true, "If the key is a script"},
                {RPCResult::Type::BOOL, "iswitness", /*optional=*/true, "If the address is a witness address"},
                {RPCResult::Type::NUM, "witness_version", /*optional=*/true, "The witness version (0 for P2WSH)"},
                {RPCResult::Type::STR_HEX, "witness_program", /*optional=*/true, "The witness program"},
                {RPCResult::Type::BOOL, "isquantum", /*optional=*/true, "If the address is a quantum address"},
                {RPCResult::Type::STR, "note", /*optional=*/true, "Additional information about the address"},
            }
        },
        RPCExamples{
            HelpExampleCli("validatequantumaddress", "\"bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3\"")
            + HelpExampleRpc("validatequantumaddress", "\"bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3\"")
        },
        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
        {
            UniValue ret(UniValue::VOBJ);
            
            std::string addr_str = request.params[0].get_str();
            CTxDestination dest = DecodeDestination(addr_str);
            bool isValid = IsValidDestination(dest);
            
            ret.pushKV("isvalid", isValid);
            
            if (isValid) {
                ret.pushKV("address", EncodeDestination(dest));
                
                // Check if it's a P2WSH address
                if (auto witness_script_hash = std::get_if<WitnessV0ScriptHash>(&dest)) {
                    ret.pushKV("iswitness", true);
                    ret.pushKV("witness_version", 0);
                    ret.pushKV("witness_program", HexStr(*witness_script_hash));
                    
                    // Generate scriptPubKey
                    CScript scriptPubKey = GetScriptForDestination(dest);
                    ret.pushKV("scriptPubKey", HexStr(scriptPubKey));
                    
                    // Note: We can't determine if this is a quantum address just from the P2WSH
                    // since it looks like any other P2WSH address
                    ret.pushKV("note", "Quantum addresses use P2WSH format. Cannot determine if quantum without witness script.");
                } else {
                    ret.pushKV("iswitness", false);
                }
            }
            
            return ret;
        },
    };
}

RPCHelpMan getquantuminfo()
{
    return RPCHelpMan{
        "getquantuminfo",
        "Returns information about quantum-safe signature support in this wallet.\n",
        {},
        RPCResult{
            RPCResult::Type::OBJ, "", "",
            {
                {RPCResult::Type::BOOL, "enabled", "Whether quantum signature support is enabled"},
                {RPCResult::Type::BOOL, "activated", "Whether quantum signatures are activated on the network"},
                {RPCResult::Type::NUM, "quantum_keys", "Number of quantum keys in the wallet"},
                {RPCResult::Type::ARR, "supported_algorithms", "List of supported quantum algorithms",
                {
                    {RPCResult::Type::OBJ, "", "",
                    {
                        {RPCResult::Type::STR, "name", "Algorithm name"},
                        {RPCResult::Type::STR, "description", "Algorithm description"},
                        {RPCResult::Type::NUM, "signature_size", "Typical signature size in bytes"},
                        {RPCResult::Type::NUM, "public_key_size", "Public key size in bytes"},
                    }},
                }},
            }
        },
        RPCExamples{
            HelpExampleCli("getquantuminfo", "")
            + HelpExampleRpc("getquantuminfo", "")
        },
        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
        {
            const std::shared_ptr<const CWallet> pwallet = GetWalletForJSONRPCRequest(request);
            if (!pwallet) return UniValue::VNULL;

            LOCK(pwallet->cs_wallet);

            UniValue ret(UniValue::VOBJ);
            
            // Check if quantum signatures are enabled
            ret.pushKV("enabled", true); // Always enabled in QSBitcoin
            
            // Check activation status (simplified for now)
            ret.pushKV("activated", true); // For testing purposes
            
            // Count quantum keys
            int quantum_key_count = 0;
            
            // First check descriptor wallets (preferred)
            if (pwallet->IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {
                for (auto& spkm : pwallet->GetAllScriptPubKeyMans()) {
                    // Count quantum keys in each SPKM
                    auto desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(spkm);
                    if (desc_spkm) {
                        quantum_key_count += desc_spkm->GetQuantumKeyCount();
                    }
                }
            }
            
            // Only count keys in descriptor wallets
            
            ret.pushKV("quantum_keys", quantum_key_count);
            
            // List supported algorithms
            UniValue algos(UniValue::VARR);
            
            UniValue ml_dsa(UniValue::VOBJ);
            ml_dsa.pushKV("name", "ml-dsa");
            ml_dsa.pushKV("description", "ML-DSA-65 (Dilithium) - Recommended for general use");
            ml_dsa.pushKV("signature_size", 3293);
            ml_dsa.pushKV("public_key_size", 1952);
            algos.push_back(std::move(ml_dsa));
            
            UniValue slh_dsa(UniValue::VOBJ);
            slh_dsa.pushKV("name", "slh-dsa");
            slh_dsa.pushKV("description", "SLH-DSA-192f (SPHINCS+) - For high-security applications");
            slh_dsa.pushKV("signature_size", 35664);
            slh_dsa.pushKV("public_key_size", 48);
            algos.push_back(std::move(slh_dsa));
            
            ret.pushKV("supported_algorithms", std::move(algos));
            
            return ret;
        },
    };
}


} // namespace wallet